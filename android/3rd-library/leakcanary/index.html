<!--
  Copyright (c) 2016-2020 Martin Donath <martin.donath@squidfunk.com>
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to
  deal in the Software without restriction, including without limitation the
  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
--> <!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=description content="An Android Developer."><link href=https://blog.yorek.xyz/about-me/android/3rd-library/leakcanary/ rel=canonical><meta name=author content="Yorek Liu"><meta name=lang:clipboard.copy content=复制><meta name=lang:clipboard.copied content=已复制><meta name=lang:search.language content=ja><meta name=lang:search.pipeline.stopwords content=True><meta name=lang:search.pipeline.trimmer content=True><meta name=lang:search.result.none content=没有找到符合条件的结果><meta name=lang:search.result.one content="找到 1 个符合条件的结果"><meta name=lang:search.result.other content="# 个符合条件的结果"><meta name=lang:search.tokenizer content=[\uff0c\u3002]+><link rel="shortcut icon" href=../../../assets/images/favicon.ico><meta name=generator content="mkdocs-1.0.4, mkdocs-material-4.6.0"><title>LeakCanary2源码解析</title><link rel=stylesheet href=../../../assets/stylesheets/application.1b62728e.css><link rel=stylesheet href=../../../assets/stylesheets/application-palette.a8b3c06d.css><meta name=theme-color content><script src=../../../assets/javascripts/modernizr.268332fc.js></script><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel=stylesheet href=../../../assets/fonts/material-icons.css><link rel=manifest href=../../../manifest.webmanifest><script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-155096376-1", "auto")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script><script async src=https://www.google-analytics.com/analytics.js></script><!-- Determine title --><!-- The image needs to have an absolute URL --><!-- Open graph meta tags --><meta property=og:type content=website><meta property=og:title content="Yorek's - LeakCanary2源码解析"><meta property=og:description content="An Android Developer."><meta content=https://blog.yorek.xyz/about-me/android/3rd-library/leakcanary/ property=og:url><meta property=og:image content=https://blog.yorek.xyz/about-meassets/images/banner.png><meta property=og:image:type content=image/png><meta property=og:image:width content=1200><meta property=og:image:height content=630><!-- Twitter meta tags --><meta name=twitter:card content=summary_large_image><meta name=twitter:site content=@squidfunk><meta name=twitter:creator content=@squidfunk><meta name=twitter:title content="Yorek's - LeakCanary2源码解析"><meta name=twitter:description content="An Android Developer."><meta name=twitter:image content=https://blog.yorek.xyz/about-meassets/images/banner.png></head> <body dir=ltr data-md-color-primary=white data-md-color-accent=blue> <svg class=md-svg> <defs> </defs> </svg> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay data-md-component=overlay for=__drawer></label> <a href=#1-what-is-a-memory-leak tabindex=1 class=md-skip> 跳转至 </a> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid"> <div class=md-flex> <div class="md-flex__cell md-flex__cell--shrink"> <a href=https://blog.yorek.xyz/about-me title="Yorek's" class="md-header-nav__button md-logo"> <img src=../../../assets/images/favicon.ico width=24 height=24> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title> <span class=md-header-nav__topic> Yorek's </span> <span class=md-header-nav__topic> LeakCanary2源码解析 </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--search md-header-nav__button" for=__search></label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=query data-md-state=active> <label class="md-icon md-search__icon" for=__search></label> <button type=reset class="md-icon md-search__icon" data-md-component=reset tabindex=-1> &#xE5CD; </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=result> <div class=md-search-result__meta> 键入以开始搜索 </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container> <nav class="md-tabs md-tabs--active" data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../3rd-library-source-code/ class="md-tabs__link md-tabs__link--active"> Android </a> </li> <li class=md-tabs__item> <a href=../../../flutter/flutter_first_project_1/ class=md-tabs__link> Flutter </a> </li> <li class=md-tabs__item> <a href=../../../leetcode/ class=md-tabs__link> LeetCode </a> </li> <li class=md-tabs__item> <a href=../../../design-pattern/design-pattern/ class=md-tabs__link> Books </a> </li> </ul> </div> </nav> <main class=md-main role=main> <div class="md-main__inner md-grid" data-md-component=container> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" data-md-level=0> <label class="md-nav__title md-nav__title--site" for=__drawer> <a href=https://blog.yorek.xyz/about-me title="Yorek's" class="md-nav__button md-logo"> <img src=../../../assets/images/favicon.ico width=48 height=48> </a> Yorek's </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. title=Home class=md-nav__link> Home </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2 type=checkbox id=nav-2 checked> <label class=md-nav__link for=nav-2> Android </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-2> Android </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2-1 type=checkbox id=nav-2-1 checked> <label class=md-nav__link for=nav-2-1> 三方库源码解析 </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-2-1> 三方库源码解析 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../3rd-library-source-code/ title=Android三方库源码分析 class=md-nav__link> Android三方库源码分析 </a> </li> <li class=md-nav__item> <a href=../matrix/ title="微信APM Matrix解析" class=md-nav__link> 微信APM Matrix解析 </a> </li> <li class=md-nav__item> <a href=../matrix-trace/ title=Matrix-TraceCanary解析 class=md-nav__link> Matrix-TraceCanary解析 </a> </li> <li class=md-nav__item> <a href=../matrix-io/ title=Matrix-IOCanary解析 class=md-nav__link> Matrix-IOCanary解析 </a> </li> <li class=md-nav__item> <a href=../matrix-resource/ title=Matrix-ResourceCanary解析 class=md-nav__link> Matrix-ResourceCanary解析 </a> </li> <li class=md-nav__item> <a href=../matrix-sqlitelint/ title=Matrix-SQLiteLint解析 class=md-nav__link> Matrix-SQLiteLint解析 </a> </li> <li class=md-nav__item> <a href=../okhttp/ title=OkHttp3源码解析 class=md-nav__link> OkHttp3源码解析 </a> </li> <li class=md-nav__item> <a href=../retrofit/ title=Retrofit2源码解析 class=md-nav__link> Retrofit2源码解析 </a> </li> <li class=md-nav__item> <a href=../rxjava&rxandroid/ title=RxJava源码解析及使用实例 class=md-nav__link> RxJava源码解析及使用实例 </a> </li> <li class=md-nav__item> <a href=../../other/RxJava/ title=RxJava操作符大全 class=md-nav__link> RxJava操作符大全 </a> </li> <li class=md-nav__item> <a href=../glide1/ title="Glide v4 源码解析（一）" class=md-nav__link> Glide v4 源码解析（一） </a> </li> <li class=md-nav__item> <a href=../glide2/ title="Glide v4 源码解析（二）" class=md-nav__link> Glide v4 源码解析（二） </a> </li> <li class=md-nav__item> <a href=../glide3/ title="Glide v4 源码解析（三）" class=md-nav__link> Glide v4 源码解析（三） </a> </li> <li class=md-nav__item> <a href=../glide4/ title="Glide v4 源码解析（四）" class=md-nav__link> Glide v4 源码解析（四） </a> </li> <li class=md-nav__item> <a href=../glide5/ title="Glide v4 源码解析（五）" class=md-nav__link> Glide v4 源码解析（五） </a> </li> <li class=md-nav__item> <a href=../glide6/ title="Glide v4 源码解析（六）" class=md-nav__link> Glide v4 源码解析（六） </a> </li> <li class=md-nav__item> <a href=../glide7/ title="Glide v4 源码解析（七）" class=md-nav__link> Glide v4 源码解析（七） </a> </li> <li class=md-nav__item> <a href=../migrate-to-glide/ title=杂记：从Picasso迁移至Glide class=md-nav__link> 杂记：从Picasso迁移至Glide </a> </li> <li class=md-nav__item> <a href=../eventbus/ title=EventBus源码解析 class=md-nav__link> EventBus源码解析 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-toggle md-nav__toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> LeakCanary2源码解析 </label> <a href=./ title=LeakCanary2源码解析 class="md-nav__link md-nav__link--active"> LeakCanary2源码解析 </a> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>目录</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#1-what-is-a-memory-leak class=md-nav__link> 1. 什么是内存泄漏 (What is a memory leak?) </a> </li> <li class=md-nav__item> <a href=#2-common-causes-for-memory-leaks class=md-nav__link> 2. 常见的内存泄漏 (Common causes for memory leaks) </a> </li> <li class=md-nav__item> <a href=#3-leakcanary2 class=md-nav__link> 3. LeakCanary2如何检测内存泄漏 </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-leakcanary2 class=md-nav__link> 3.1 LeakCanary2初始化 </a> </li> <li class=md-nav__item> <a href=#32-activityfragment class=md-nav__link> 3.2 如何观察Activity、Fragment </a> </li> <li class=md-nav__item> <a href=#33 class=md-nav__link> 3.3 内存泄漏判定 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#__comments class="md-nav__link md-nav__link--active"> 评论 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../permissiondispatcher/ title=PermissionDispatcher源码解析 class=md-nav__link> PermissionDispatcher源码解析 </a> </li> <li class=md-nav__item> <a href=../../other/constraintlayout/ title=ConstraintLayout使用大全 class=md-nav__link> ConstraintLayout使用大全 </a> </li> <li class=md-nav__item> <a href=../../other/dagger2/ title=初学者的Dagger2教程 class=md-nav__link> 初学者的Dagger2教程 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2-2 type=checkbox id=nav-2-2> <label class=md-nav__link for=nav-2-2> Android开发高手课 </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-2-2> Android开发高手课 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../paid/master/ title=Android开发高手课 class=md-nav__link> Android开发高手课 </a> </li> <li class=md-nav__item> <a href=../../paid/master/crash_1/ title="01 | 崩溃优化（上）：关于“崩溃”那些事儿" class=md-nav__link> 01 | 崩溃优化（上）：关于“崩溃”那些事儿 </a> </li> <li class=md-nav__item> <a href=../../paid/master/crash_2/ title="02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？" class=md-nav__link> 02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/memory_1/ title="03 | 内存优化（上）：4GB内存时代，再谈内存优化" class=md-nav__link> 03 | 内存优化（上）：4GB内存时代，再谈内存优化 </a> </li> <li class=md-nav__item> <a href=../../paid/master/memory_2/ title="04 | 内存优化（下）：内存优化这件事，应该从哪里着手？" class=md-nav__link> 04 | 内存优化（下）：内存优化这件事，应该从哪里着手？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/stuck_1/ title="05 | 卡顿优化（上）：你要掌握的卡顿分析方法" class=md-nav__link> 05 | 卡顿优化（上）：你要掌握的卡顿分析方法 </a> </li> <li class=md-nav__item> <a href=../../paid/master/stuck_2/ title="06 | 卡顿优化（下）：如何监控应用卡顿？" class=md-nav__link> 06 | 卡顿优化（下）：如何监控应用卡顿？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/stuck_3/ title="06补充篇 | 卡顿优化：卡顿现场与卡顿分析" class=md-nav__link> 06补充篇 | 卡顿优化：卡顿现场与卡顿分析 </a> </li> <li class=md-nav__item> <a href=../../paid/master/start_1/ title="07 | 启动优化（上）：从启动过程看启动速度优化" class=md-nav__link> 07 | 启动优化（上）：从启动过程看启动速度优化 </a> </li> <li class=md-nav__item> <a href=../../paid/master/start_2/ title="08 | 启动优化（下）：优化启动速度的进阶方法" class=md-nav__link> 08 | 启动优化（下）：优化启动速度的进阶方法 </a> </li> <li class=md-nav__item> <a href=../../paid/master/io_1/ title="09 | I/O优化（上）：开发工程师必备的I/O优化知识" class=md-nav__link> 09 | I/O优化（上）：开发工程师必备的I/O优化知识 </a> </li> <li class=md-nav__item> <a href=../../paid/master/io_2/ title="10 | I/O优化（中）：不同I/O方式的使用场景是什么？" class=md-nav__link> 10 | I/O优化（中）：不同I/O方式的使用场景是什么？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/io_3/ title="11 | I/O优化（下）：如何监控线上I/O操作？" class=md-nav__link> 11 | I/O优化（下）：如何监控线上I/O操作？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/storage_1/ title="12 | 存储优化（上）：常见的数据存储方法有哪些？" class=md-nav__link> 12 | 存储优化（上）：常见的数据存储方法有哪些？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/storage_2/ title="13 | 存储优化（中）：如何优化数据存储？" class=md-nav__link> 13 | 存储优化（中）：如何优化数据存储？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/storage_3/ title="14 | 存储优化（下）：数据库SQLite的使用和优化" class=md-nav__link> 14 | 存储优化（下）：数据库SQLite的使用和优化 </a> </li> <li class=md-nav__item> <a href=../../paid/master/network_1/ title="15 | 网络优化（上）：移动开发工程师必备的网络优化知识" class=md-nav__link> 15 | 网络优化（上）：移动开发工程师必备的网络优化知识 </a> </li> <li class=md-nav__item> <a href=../../paid/master/network_2/ title="16 | 网络优化（中）：复杂多变的移动网络该如何优化？" class=md-nav__link> 16 | 网络优化（中）：复杂多变的移动网络该如何优化？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/network_3/ title="17 | 网络优化（下）：大数据下网络该如何监控？" class=md-nav__link> 17 | 网络优化（下）：大数据下网络该如何监控？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/battery_1/ title="18 | 耗电优化（上）：从电量优化的演进看耗电分析" class=md-nav__link> 18 | 耗电优化（上）：从电量优化的演进看耗电分析 </a> </li> <li class=md-nav__item> <a href=../../paid/master/battery_2/ title="19 | 耗电优化（下）：耗电的优化方法与线上监控" class=md-nav__link> 19 | 耗电优化（下）：耗电的优化方法与线上监控 </a> </li> <li class=md-nav__item> <a href=../../paid/master/ui_1/ title="20 | UI 优化（上）：UI 渲染的几个关键概念" class=md-nav__link> 20 | UI 优化（上）：UI 渲染的几个关键概念 </a> </li> <li class=md-nav__item> <a href=../../paid/master/ui_2/ title="21 | UI 优化（下）：如何优化 UI 渲染？" class=md-nav__link> 21 | UI 优化（下）：如何优化 UI 渲染？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/package_1/ title="22 | 包体积优化（上）：如何减少安装包大小？" class=md-nav__link> 22 | 包体积优化（上）：如何减少安装包大小？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/package_2/ title="23 | 包体积优化（下）：资源优化的进阶实践" class=md-nav__link> 23 | 包体积优化（下）：资源优化的进阶实践 </a> </li> <li class=md-nav__item> <a href=../../paid/master/compile/ title="26 | 关于编译，你需要了解什么？" class=md-nav__link> 26 | 关于编译，你需要了解什么？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/bytecode/ title="27 | 编译插桩的三种方法：AspectJ、ASM、ReDex" class=md-nav__link> 27 | 编译插桩的三种方法：AspectJ、ASM、ReDex </a> </li> <li class=md-nav__item> <a href=../../paid/master/native_hook/ title="35 | Native Hook 技术，天使还是魔鬼？" class=md-nav__link> 35 | Native Hook 技术，天使还是魔鬼？ </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2-3 type=checkbox id=nav-2-3> <label class=md-nav__link for=nav-2-3> Framework系列 </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-2-3> Framework系列 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../framework/Android四大组件(1)/ title=Activity class=md-nav__link> Activity </a> </li> <li class=md-nav__item> <a href=../../framework/Android四大组件(2)/ title=Service class=md-nav__link> Service </a> </li> <li class=md-nav__item> <a href=../../framework/Android四大组件(3)/ title=Broadcasts class=md-nav__link> Broadcasts </a> </li> <li class=md-nav__item> <a href=../../framework/Android四大组件(4)/ title="Content Providers与Fragment" class=md-nav__link> Content Providers与Fragment </a> </li> <li class=md-nav__item> <a href=../../framework/IPC机制/ title=IPC机制 class=md-nav__link> IPC机制 </a> </li> <li class=md-nav__item> <a href=../../framework/View的事件体系/ title=View的事件体系 class=md-nav__link> View的事件体系 </a> </li> <li class=md-nav__item> <a href=../../framework/View的绘制原理/ title=View的绘制原理 class=md-nav__link> View的绘制原理 </a> </li> <li class=md-nav__item> <a href=../../framework/RemoteViews/ title=RemoteViews class=md-nav__link> RemoteViews </a> </li> <li class=md-nav__item> <a href=../../framework/Drawable/ title=Android中的Drawable资源 class=md-nav__link> Android中的Drawable资源 </a> </li> <li class=md-nav__item> <a href=../../framework/Android动画/ title=Android动画 class=md-nav__link> Android动画 </a> </li> <li class=md-nav__item> <a href=../../framework/Window与WindowManager/ title=Window与WindowManager class=md-nav__link> Window与WindowManager </a> </li> <li class=md-nav__item> <a href=../../framework/四大组件启动过程/ title=四大组件启动过程 class=md-nav__link> 四大组件启动过程 </a> </li> <li class=md-nav__item> <a href=../../framework/Android消息机制/ title=Android消息机制 class=md-nav__link> Android消息机制 </a> </li> <li class=md-nav__item> <a href=../../framework/Android线程与线程池/ title=Android线程与线程池 class=md-nav__link> Android线程与线程池 </a> </li> <li class=md-nav__item> <a href=../../framework/Bitmap的缓存与加载/ title=Bitmap的缓存与加载 class=md-nav__link> Bitmap的缓存与加载 </a> </li> <li class=md-nav__item> <a href=../../framework/JNI与NDK/ title=JNI与NDK编程简介 class=md-nav__link> JNI与NDK编程简介 </a> </li> <li class=md-nav__item> <a href=../../framework/性能优化/ title=Android性能优化 class=md-nav__link> Android性能优化 </a> </li> <li class=md-nav__item> <a href=../../framework/binder1-mediaservice/ title=Binder深入理解——以MediaService为例 class=md-nav__link> Binder深入理解——以MediaService为例 </a> </li> <li class=md-nav__item> <a href=../../framework/binder2/ title=Binder深入理解——罗老师系列 class=md-nav__link> Binder深入理解——罗老师系列 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2-4 type=checkbox id=nav-2-4> <label class=md-nav__link for=nav-2-4> 付费知识归档 </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-2-4> 付费知识归档 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2-4-1 type=checkbox id=nav-2-4-1> <label class=md-nav__link for=nav-2-4-1> 某圈问题索引 </label> <nav class=md-nav data-md-component=collapsible data-md-level=3> <label class=md-nav__title for=nav-2-4-1> 某圈问题索引 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../paid/zsxq/zsxq_index/ title=某圈问题索引 class=md-nav__link> 某圈问题索引 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week1-synchronized/ title=理解Java中synchronized关键词 class=md-nav__link> 理解Java中synchronized关键词 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week2-service/ title=理解Service class=md-nav__link> 理解Service </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week3-activity/ title=理解Activity的启动模式 class=md-nav__link> 理解Activity的启动模式 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week4-startActivityForResult/ title=关于startActivityForResult class=md-nav__link> 关于startActivityForResult </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week5-view/ title=关于View的知识 class=md-nav__link> 关于View的知识 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week6-gradle/ title=关于Gradle的知识 class=md-nav__link> 关于Gradle的知识 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week7-serialization/ title=关于序列化的知识 class=md-nav__link> 关于序列化的知识 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week10-classloader/ title=Android中的ClassLoader class=md-nav__link> Android中的ClassLoader </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week11-binder/ title=Binder简介 class=md-nav__link> Binder简介 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week12-retrofit-okhttp/ title=OkHttp和Retrofit的作用以及两者之间的联系 class=md-nav__link> OkHttp和Retrofit的作用以及两者之间的联系 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week14-jvm-gc/ title=JVM中垃圾回收策略 class=md-nav__link> JVM中垃圾回收策略 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week16-keep-app-alive/ title=进程保活 class=md-nav__link> 进程保活 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week17-android-components/ title=四大组件的作用以及多进程 class=md-nav__link> 四大组件的作用以及多进程 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week20-network-protocol/ title=网络协议 class=md-nav__link> 网络协议 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week21-mvc&amp;mvp&mvvm/ title=MVC、MVP和MVVM class=md-nav__link> MVC、MVP和MVVM </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week22-android-studio-build/ title="Android Studio build过程" class=md-nav__link> Android Studio build过程 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week23-load-large-bitmap/ title=大尺寸图片加载问题 class=md-nav__link> 大尺寸图片加载问题 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2-5 type=checkbox id=nav-2-5> <label class=md-nav__link for=nav-2-5> 日常记录 </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-2-5> 日常记录 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../other/annotation/ title=注解的定义及解析 class=md-nav__link> 注解的定义及解析 </a> </li> <li class=md-nav__item> <a href=../../other/best_throttle_in_mvvm/ title=这可能是MVVM中最优雅的按键防抖方案 class=md-nav__link> 这可能是MVVM中最优雅的按键防抖方案 </a> </li> <li class=md-nav__item> <a href=../../other/android-jenkins/ title="Jenkins for android" class=md-nav__link> Jenkins for android </a> </li> <li class=md-nav__item> <a href=../../other/SystemProrities/ title=普通Android程序使用SystemProrities class=md-nav__link> 普通Android程序使用SystemProrities </a> </li> <li class=md-nav__item> <a href=../../other/recyclerview-cache/ title=ListView、RecyclerView缓存策略解析 class=md-nav__link> ListView、RecyclerView缓存策略解析 </a> </li> <li class=md-nav__item> <a href=../../other/recyclerview-item-docoration/ title=RecyclerView高级特性——ItemDecoration class=md-nav__link> RecyclerView高级特性——ItemDecoration </a> </li> <li class=md-nav__item> <a href=../../other/recyclerview-others/ title=RecyclerView的一些使用细节 class=md-nav__link> RecyclerView的一些使用细节 </a> </li> <li class=md-nav__item> <a href=../../other/RecyclerView-Sort&Delete/ title=RecyclerView高级特性——拖拽排序以及滑动删除 class=md-nav__link> RecyclerView高级特性——拖拽排序以及滑动删除 </a> </li> <li class=md-nav__item> <a href=../../other/FAB-Behavior/ title=FloatingActionButton上滑隐藏下滑显示 class=md-nav__link> FloatingActionButton上滑隐藏下滑显示 </a> </li> <li class=md-nav__item> <a href=../../other/nestedscrolling/ title=NestedScrolling机制 class=md-nav__link> NestedScrolling机制 </a> </li> <li class=md-nav__item> <a href=../../other/porterduff/ title=使用Porter-Duff合成数字图像 class=md-nav__link> 使用Porter-Duff合成数字图像 </a> </li> <li class=md-nav__item> <a href=../../other/runtime/ title="Android Runtime" class=md-nav__link> Android Runtime </a> </li> <li class=md-nav__item> <a href=../../other/android_alias/ title=Android马甲包的那些事儿 class=md-nav__link> Android马甲包的那些事儿 </a> </li> <li class=md-nav__item> <a href=../../other/Android-Development-Tool/ title=Android神兵利器 class=md-nav__link> Android神兵利器 </a> </li> <li class=md-nav__item> <a href=../../other/FileProvider/ title=FileProvider class=md-nav__link> FileProvider </a> </li> <li class=md-nav__item> <a href=../../other/Android判断导航栏高度/ title=Android判断虚拟按键(导航栏)显示与否、高度以及获取屏幕实际高度 class=md-nav__link> Android判断虚拟按键(导航栏)显示与否、高度以及获取屏幕实际高度 </a> </li> <li class=md-nav__item> <a href=../../other/Android图片选择器/ title=Android图片选择器 class=md-nav__link> Android图片选择器 </a> </li> <li class=md-nav__item> <a href=../../other/Android底部导航栏框架/ title=Android原生底部导航栏 class=md-nav__link> Android原生底部导航栏 </a> </li> <li class=md-nav__item> <a href=../../other/Android搜索栏的实现/ title=Android搜索栏的实现 class=md-nav__link> Android搜索栏的实现 </a> </li> <li class=md-nav__item> <a href=../../other/Android暂停音乐播放器的播放/ title=Android暂停酷狗、网易云音乐等音乐播放器的播放 class=md-nav__link> Android暂停酷狗、网易云音乐等音乐播放器的播放 </a> </li> <li class=md-nav__item> <a href=../../other/Android滑动返回实践/ title=Android滑动返回实践 class=md-nav__link> Android滑动返回实践 </a> </li> <li class=md-nav__item> <a href=../../other/Android程序反编译/ title=MacOS下Android程序反编译 class=md-nav__link> MacOS下Android程序反编译 </a> </li> <li class=md-nav__item> <a href=../../other/Android通讯录快速读取/ title=Android通讯录快速读取 class=md-nav__link> Android通讯录快速读取 </a> </li> <li class=md-nav__item> <a href=../../other/soft-keyboard-in-app/ title=App内自定义软键盘 class=md-nav__link> App内自定义软键盘 </a> </li> <li class=md-nav__item> <a href=../../other/腾讯X5内核入坑指南/ title="腾讯TBS X5浏览器内核入坑指南" class=md-nav__link> 腾讯TBS X5浏览器内核入坑指南 </a> </li> <li class=md-nav__item> <a href=../../other/琐碎知识点/ title=琐碎知识点 class=md-nav__link> 琐碎知识点 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-3 type=checkbox id=nav-3> <label class=md-nav__link for=nav-3> Flutter </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-3> Flutter </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../flutter/flutter_first_project_1/ title=年轻人的第一个Flutter程序(1) class=md-nav__link> 年轻人的第一个Flutter程序(1) </a> </li> <li class=md-nav__item> <a href=../../../flutter/flutter_first_project_2/ title=年轻人的第一个Flutter程序(2) class=md-nav__link> 年轻人的第一个Flutter程序(2) </a> </li> <li class=md-nav__item> <a href=../../../flutter/flutter_first_project_3/ title=年轻人的第一个Flutter程序(3) class=md-nav__link> 年轻人的第一个Flutter程序(3) </a> </li> <li class=md-nav__item> <a href=../../../flutter/flutter_first_project_4/ title=年轻人的第一个Flutter程序(4) class=md-nav__link> 年轻人的第一个Flutter程序(4) </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-4 type=checkbox id=nav-4> <label class=md-nav__link for=nav-4> LeetCode </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-4> LeetCode </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../leetcode/ title=算法目录 class=md-nav__link> 算法目录 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_1/ title=数据结构、算法和数据操作 class=md-nav__link> 数据结构、算法和数据操作 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_3/ title=高质量的代码 class=md-nav__link> 高质量的代码 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_4/ title=解决问题的思路 class=md-nav__link> 解决问题的思路 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_5/ title=优化时间和空间效率 class=md-nav__link> 优化时间和空间效率 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_6/ title=面试中的各项能力 class=md-nav__link> 面试中的各项能力 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/array/ title=Array class=md-nav__link> Array </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode1-10/ title=LeetCode(1-10) class=md-nav__link> LeetCode(1-10) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode11-20/ title=LeetCode(11-20) class=md-nav__link> LeetCode(11-20) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode21-30/ title=LeetCode(21-30) class=md-nav__link> LeetCode(21-30) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode31-40/ title=LeetCode(31-40) class=md-nav__link> LeetCode(31-40) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode41-50/ title=LeetCode(41-50) class=md-nav__link> LeetCode(41-50) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode51-60/ title=LeetCode(51-60) class=md-nav__link> LeetCode(51-60) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode61-70/ title=LeetCode(61-70) class=md-nav__link> LeetCode(61-70) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode71-80/ title=LeetCode(71-80) class=md-nav__link> LeetCode(71-80) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode81-90/ title=LeetCode(81-90) class=md-nav__link> LeetCode(81-90) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode91-100/ title=LeetCode(91-100) class=md-nav__link> LeetCode(91-100) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode101-110/ title=LeetCode(101-110) class=md-nav__link> LeetCode(101-110) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode111-120/ title=LeetCode(111-120) class=md-nav__link> LeetCode(111-120) </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-5 type=checkbox id=nav-5> <label class=md-nav__link for=nav-5> Books </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-5> Books </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-5-1 type=checkbox id=nav-5-1> <label class=md-nav__link for=nav-5-1> Design Pattern </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-5-1> Design Pattern </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../design-pattern/design-pattern/ title=设计模式概述 class=md-nav__link> 设计模式概述 </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/design-principle/ title=面向对象的六大原则 class=md-nav__link> 面向对象的六大原则 </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/singleton/ title=单例模式(Singleton) class=md-nav__link> 单例模式(Singleton) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/builder/ title=建造者模式(Builder) class=md-nav__link> 建造者模式(Builder) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/prototype/ title=原型模式(Prototype) class=md-nav__link> 原型模式(Prototype) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/factory-method/ title="工厂方法模式(Factory method)" class=md-nav__link> 工厂方法模式(Factory method) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/abstract-factory/ title="抽象工厂模式(Abstract factory)" class=md-nav__link> 抽象工厂模式(Abstract factory) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/proxy/ title=代理模式(Proxy) class=md-nav__link> 代理模式(Proxy) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/composite/ title=组合模式(Composite) class=md-nav__link> 组合模式(Composite) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/adapter/ title=适配器模式(Adapter) class=md-nav__link> 适配器模式(Adapter) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/decorator/ title=装饰模式(Decorator) class=md-nav__link> 装饰模式(Decorator) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/flyweight/ title=享元模式(Flyweight) class=md-nav__link> 享元模式(Flyweight) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/facade/ title=外观模式(Facade) class=md-nav__link> 外观模式(Facade) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/bridge/ title=桥接模式(Bridge) class=md-nav__link> 桥接模式(Bridge) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/strategy/ title=策略模式(Strategy) class=md-nav__link> 策略模式(Strategy) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/state/ title=状态模式(State) class=md-nav__link> 状态模式(State) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/chain-of-responsibility/ title="责任链模式(Chain of responsibility)" class=md-nav__link> 责任链模式(Chain of responsibility) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/interpreter/ title=解释器模式(Interpreter) class=md-nav__link> 解释器模式(Interpreter) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/command/ title=命令模式(Command) class=md-nav__link> 命令模式(Command) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/observer/ title=观察者模式(Observer) class=md-nav__link> 观察者模式(Observer) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/memento/ title=备忘录模式(Memento) class=md-nav__link> 备忘录模式(Memento) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/iterator/ title=迭代器模式(Iterator) class=md-nav__link> 迭代器模式(Iterator) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/template-method/ title="模版方法模式(Template method)" class=md-nav__link> 模版方法模式(Template method) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/visitor/ title=访问者模式(Visitor) class=md-nav__link> 访问者模式(Visitor) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/mediator/ title=中介者模式(Mediator) class=md-nav__link> 中介者模式(Mediator) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/confusing-design-pattern/ title=易混淆的设计模式 class=md-nav__link> 易混淆的设计模式 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-5-2 type=checkbox id=nav-5-2> <label class=md-nav__link for=nav-5-2> Effective Java </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-5-2> Effective Java </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../effective-java/effective-java/ title="Effective Java概述" class=md-nav__link> Effective Java概述 </a> </li> <li class=md-nav__item> <a href=../../../effective-java/chapter1/ title=创建和销毁对象 class=md-nav__link> 创建和销毁对象 </a> </li> <li class=md-nav__item> <a href=../../../effective-java/chapter2/ title=对于所有对象都通用的方法 class=md-nav__link> 对于所有对象都通用的方法 </a> </li> <li class=md-nav__item> <a href=../../../effective-java/chapter3/ title=类和接口 class=md-nav__link> 类和接口 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-5-3 type=checkbox id=nav-5-3> <label class=md-nav__link for=nav-5-3> JVM </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-5-3> JVM </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../jvm/jvm-content/ title=深入理解Java虚拟机 class=md-nav__link> 深入理解Java虚拟机 </a> </li> <li class=md-nav__item> <a href=../../../jvm/java-memory-area-oom/ title=Java内存区域与内存溢出异常 class=md-nav__link> Java内存区域与内存溢出异常 </a> </li> <li class=md-nav__item> <a href=../../../jvm/java-gc/ title=垃圾收集器与内存分配策略 class=md-nav__link> 垃圾收集器与内存分配策略 </a> </li> <li class=md-nav__item> <a href=../../../jvm/class-struct/ title=类文件结构 class=md-nav__link> 类文件结构 </a> </li> <li class=md-nav__item> <a href=../../../jvm/load-class/ title=虚拟机类加载机制 class=md-nav__link> 虚拟机类加载机制 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-5-4 type=checkbox id=nav-5-4> <label class=md-nav__link for=nav-5-4> Java </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-5-4> Java </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../java/generics-java-kotlin/ title=Java&Kotlin在泛型方面的区别 class=md-nav__link> Java&Kotlin在泛型方面的区别 </a> </li> <li class=md-nav__item> <a href=../../../java/java-collections/ title=Java集合总结 class=md-nav__link> Java集合总结 </a> </li> <li class=md-nav__item> <a href=../../../java/java-foundation/ title=Java常见概念 class=md-nav__link> Java常见概念 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-5-5 type=checkbox id=nav-5-5> <label class=md-nav__link for=nav-5-5> Refactoring </label> <nav class=md-nav data-md-component=collapsible data-md-level=2> <label class=md-nav__title for=nav-5-5> Refactoring </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../refactoring/refactoring/ title=重构：改善既有代码的设计 class=md-nav__link> 重构：改善既有代码的设计 </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>目录</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#1-what-is-a-memory-leak class=md-nav__link> 1. 什么是内存泄漏 (What is a memory leak?) </a> </li> <li class=md-nav__item> <a href=#2-common-causes-for-memory-leaks class=md-nav__link> 2. 常见的内存泄漏 (Common causes for memory leaks) </a> </li> <li class=md-nav__item> <a href=#3-leakcanary2 class=md-nav__link> 3. LeakCanary2如何检测内存泄漏 </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-leakcanary2 class=md-nav__link> 3.1 LeakCanary2初始化 </a> </li> <li class=md-nav__item> <a href=#32-activityfragment class=md-nav__link> 3.2 如何观察Activity、Fragment </a> </li> <li class=md-nav__item> <a href=#33 class=md-nav__link> 3.3 内存泄漏判定 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#__comments class="md-nav__link md-nav__link--active"> 评论 </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1>LeakCanary2源码解析</h1> <div class="admonition info"> <p class=admonition-title>Info</p> <p>本文基于<a href=https://github.com/square/leakcanary/tree/v2.0-beta-3>LeakCanary</a>最新2.0-beta-3版本进行分析。</p> </div> <p>众所周知，LeakCanary是一个内存泄漏检测的工具。那么，内存泄漏是如何定义的，通常有哪些情况呢？<br> 在分析源代码之前，我们先弄清楚这两个问题。这两个问题在<a href=https://square.github.io/leakcanary/fundamentals/ >LeakCanary - Fundamentals</a>中有提及。</p> <h2 id=1-what-is-a-memory-leak>1. 什么是内存泄漏 (What is a memory leak?)<a class=headerlink href=#1-what-is-a-memory-leak title="Permanent link">&para;</a></h2> <p>In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash.<br> 在基于Java的运行时中，内存泄漏是一种编程错误，它导致应用程序保留对不再需要的对象的引用。这会导致为该对象分配的内存无法回收，最终导致<code>OutOfMemoryError</code>崩溃。</p> <p>For example, an Android activity instance is no longer needed after its onDestroy() method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.<br> 例如，在Activity的<code>onDestroy()</code>方法被调用后，Android activity的实例就不再需要了，此时在静态字段中存储该Activity的引用将阻止其被回收。</p> <h2 id=2-common-causes-for-memory-leaks>2. 常见的内存泄漏 (Common causes for memory leaks)<a class=headerlink href=#2-common-causes-for-memory-leaks title="Permanent link">&para;</a></h2> <p>Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes:<br> 大多数内存泄漏是由与对象生命周期相关的错误引起的。以下是一些常见的Android错误：</p> <ul> <li>Storing an Activity context as a field in an object that survives activity recreation due to configuration changes.<br> 将Activity上下文存储为对象中的字段，这样配置更改后activity会重新创建，但是老的仍然存活。</li> <li>Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end.<br> 对有生命周期的对象注册了监听器、广播接收者或者RxJava的订阅，且当对象的生命到达了终点时没有取消注册。</li> <li>Storing a view in a static field, and not clearing that field when the view is detached.<br> 在静态字段中存储了view，且当view detach时没有清空静态变量。</li> </ul> <h2 id=3-leakcanary2>3. LeakCanary2如何检测内存泄漏<a class=headerlink href=#3-leakcanary2 title="Permanent link">&para;</a></h2> <p>LeakCanary v2 与 v1 的代码由略微的不同，下面是两者的检测内存泄漏的原理。</p> <blockquote> <p><strong>LeakCanary 1.5.1 检测内存泄漏原理</strong>：<br> 在Activity destroy后将Activity的弱引用关联到ReferenceQueue中，这样Activity将要被GC前，会出现在ReferenceQueue中。<br> 随后，会向主线程的MessageQueue添加一个<code>IdleHandler</code>，用于在idle时触发一个发生在HandlerThread的等待5秒后开始检测内存泄漏的代码。<br> 这段代码首先会判断是否对象出现在引用队列中，如果有，则说明没有内存泄漏，结束。否则，调用<code>Runtime.getRuntime().gc()</code>进行GC，等待100ms后再次判断是否已经出现在引用队列中，若还没有被出现，那么说明有内存泄漏，开始dump hprof。</p> <p><strong>LeakCanary 2.0 beta 3 检测内存泄漏原理</strong>：<br> 在Activity destroy后将Activity的弱引用关联到ReferenceQueue中，这样Activity将要被GC前，会出现在ReferenceQueue中。<br> 随后，会向主线程的抛出一个5秒后执行的Runnable，用于检测内存泄漏。<br> 这段代码首先会将引用队列中出现的对象从观察对象数组中移除，然后再判断要观察的此对象是否存在。若不存在，则说明没有内存泄漏，结束。否则，就说明可能出现了内存泄漏，会调用<code>Runtime.getRuntime().gc()</code>进行GC，等待100ms后再次根据引用队列判断，若仍然出现在引用队列中，那么说明有内存泄漏，此时根据内存泄漏的个数弹出通知或者开始dump hprof。</p> </blockquote> <h3 id=31-leakcanary2>3.1 LeakCanary2初始化<a class=headerlink href=#31-leakcanary2 title="Permanent link">&para;</a></h3> <p>LeakCanary 2.0使用非常简单，只需要在build.gradle中配置一下，无需在项目中添加任何代码。</p> <div class=codehilite><pre><span></span>dependencies {
  // debugImplementation because LeakCanary should only run in debug builds.
  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.0-beta-3&#39;
}
</pre></div> <p>原理就是利用ContentProvider的特性，其onCreate方法会在Application的onCreate方法之前被系统调用。所以只需要在AndroidManifest.xml中配置一下这个ContentProvider，然后在onCreate方法中进行初始化即可。 </p> <p><strong>leakcanary-object-watcher-android/src/main/AndroidManifest.xml</strong></p> <div class=codehilite><pre><span></span><span class=cp>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class=nt>&lt;manifest</span>
    <span class=na>xmlns:android=</span><span class=s>&quot;http://schemas.android.com/apk/res/android&quot;</span>
    <span class=na>package=</span><span class=s>&quot;com.squareup.leakcanary.objectwatcher&quot;</span>
    <span class=nt>&gt;</span>

  <span class=nt>&lt;application&gt;</span>
    <span class=nt>&lt;provider</span>
        <span class=na>android:name=</span><span class=s>&quot;leakcanary.internal.AppWatcherInstaller$MainProcess&quot;</span>
        <span class=na>android:authorities=</span><span class=s>&quot;${applicationId}.leakcanary-installer&quot;</span>
        <span class=na>android:exported=</span><span class=s>&quot;false&quot;</span><span class=nt>/&gt;</span>
  <span class=nt>&lt;/application&gt;</span>
<span class=nt>&lt;/manifest&gt;</span>
</pre></div> <p><strong>leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt</strong></p> <div class=codehilite><pre><span></span><span class=cm>/**</span>
<span class=cm> * Content providers are loaded before the application class is created. [AppWatcherInstaller] is</span>
<span class=cm> * used to install [leakcanary.AppWatcher] on application start.</span>
<span class=cm> */</span>
<span class=k>internal</span> <span class=k>sealed</span> <span class=k>class</span> <span class=nc>AppWatcherInstaller</span> <span class=p>:</span> <span class=n>ContentProvider</span><span class=p>()</span> <span class=p>{</span>

  <span class=cm>/**</span>
<span class=cm>   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span>
<span class=cm>   */</span>
  <span class=k>internal</span> <span class=k>class</span> <span class=nc>MainProcess</span> <span class=p>:</span> <span class=n>AppWatcherInstaller</span><span class=p>()</span>

  <span class=cm>/**</span>
<span class=cm>   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span>
<span class=cm>   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span>
<span class=cm>   */</span>
  <span class=k>internal</span> <span class=k>class</span> <span class=nc>LeakCanaryProcess</span> <span class=p>:</span> <span class=n>AppWatcherInstaller</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onCreate</span><span class=p>():</span> <span class=n>Boolean</span> <span class=p>{</span>
      <span class=k>super</span><span class=p>.</span><span class=n>onCreate</span><span class=p>()</span>
      <span class=n>AppWatcher</span><span class=p>.</span><span class=n>config</span> <span class=p>=</span> <span class=n>AppWatcher</span><span class=p>.</span><span class=n>config</span><span class=p>.</span><span class=n>copy</span><span class=p>(</span><span class=n>enabled</span> <span class=p>=</span> <span class=k>false</span><span class=p>)</span>
      <span class=k>return</span> <span class=k>true</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>onCreate</span><span class=p>():</span> <span class=n>Boolean</span> <span class=p>{</span>
    <span class=k>val</span> <span class=py>application</span> <span class=p>=</span> <span class=n>context</span><span class=o>!!</span><span class=p>.</span><span class=n>applicationContext</span> <span class=k>as</span> <span class=n>Application</span>
    <span class=n>InternalAppWatcher</span><span class=p>.</span><span class=n>install</span><span class=p>(</span><span class=n>application</span><span class=p>)</span>
    <span class=k>return</span> <span class=k>true</span>
  <span class=p>}</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>query</span><span class=p>(</span>
    <span class=n>uri</span><span class=p>:</span> <span class=n>Uri</span><span class=p>,</span>
    <span class=n>strings</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;?,</span>
    <span class=n>s</span><span class=p>:</span> <span class=n>String</span><span class=p>?,</span>
    <span class=n>strings1</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;?,</span>
    <span class=n>s1</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span>
  <span class=p>):</span> <span class=n>Cursor</span><span class=p>?</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>null</span>
  <span class=p>}</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>getType</span><span class=p>(</span><span class=n>uri</span><span class=p>:</span> <span class=n>Uri</span><span class=p>):</span> <span class=n>String</span><span class=p>?</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>null</span>
  <span class=p>}</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>insert</span><span class=p>(</span>
    <span class=n>uri</span><span class=p>:</span> <span class=n>Uri</span><span class=p>,</span>
    <span class=n>contentValues</span><span class=p>:</span> <span class=n>ContentValues</span><span class=p>?</span>
  <span class=p>):</span> <span class=n>Uri</span><span class=p>?</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>null</span>
  <span class=p>}</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>delete</span><span class=p>(</span>
    <span class=n>uri</span><span class=p>:</span> <span class=n>Uri</span><span class=p>,</span>
    <span class=n>s</span><span class=p>:</span> <span class=n>String</span><span class=p>?,</span>
    <span class=n>strings</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;?</span>
  <span class=p>):</span> <span class=n>Int</span> <span class=p>{</span>
    <span class=k>return</span> <span class=m>0</span>
  <span class=p>}</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>update</span><span class=p>(</span>
    <span class=n>uri</span><span class=p>:</span> <span class=n>Uri</span><span class=p>,</span>
    <span class=n>contentValues</span><span class=p>:</span> <span class=n>ContentValues</span><span class=p>?,</span>
    <span class=n>s</span><span class=p>:</span> <span class=n>String</span><span class=p>?,</span>
    <span class=n>strings</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;?</span>
  <span class=p>):</span> <span class=n>Int</span> <span class=p>{</span>
    <span class=k>return</span> <span class=m>0</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>我们可以看到，该ContentProvider除了在onCreate方法中进行了初始化处理，其他方法都是空实现。在上面的第26行，onCreate方法中初始化代码为<code>InternalAppWatcher.install(application)</code>。</p> <p><code>InternalAppWatcher.install(Application)</code>方法完成了LeakCanary的初始化操作，里面涉及到协作的一些类的定义。</p> <p><strong>leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt</strong></p> <div class=codehilite><pre><span></span><span class=k>internal</span> <span class=k>object</span> <span class=nc>InternalAppWatcher</span> <span class=p>{</span>

  <span class=c1>// 通过判断lateinit修饰的Application是否已经初始化，来判断LeakCanary是否已经安装</span>
  <span class=k>val</span> <span class=py>isInstalled</span>
    <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=o>::</span><span class=n>application</span><span class=p>.</span><span class=n>isInitialized</span>

  <span class=c1>// LeakCanary安装完成的回调，实际上对应的是leakcanary.internal.InternalLeakCanary这个类</span>
  <span class=k>private</span> <span class=k>val</span> <span class=py>onAppWatcherInstalled</span><span class=p>:</span> <span class=p>(</span><span class=n>Application</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>Unit</span>

  <span class=k>val</span> <span class=py>isDebuggableBuild</span> <span class=k>by</span> <span class=n>lazy</span> <span class=p>{</span>
    <span class=p>(</span><span class=n>application</span><span class=p>.</span><span class=n>applicationInfo</span><span class=p>.</span><span class=n>flags</span> <span class=n>and</span> <span class=n>ApplicationInfo</span><span class=p>.</span><span class=n>FLAG_DEBUGGABLE</span><span class=p>)</span> <span class=p>!=</span> <span class=m>0</span>
  <span class=p>}</span>

  <span class=k>lateinit</span> <span class=k>var</span> <span class=py>application</span><span class=p>:</span> <span class=n>Application</span>

  <span class=c1>// ObjectWatcher参数1</span>
  <span class=k>private</span> <span class=k>val</span> <span class=py>clock</span> <span class=p>=</span> <span class=k>object</span> <span class=p>:</span> <span class=nc>Clock</span> <span class=p>{</span>
    <span class=k>override</span> <span class=k>fun</span> <span class=nf>uptimeMillis</span><span class=p>():</span> <span class=n>Long</span> <span class=p>{</span>
      <span class=k>return</span> <span class=n>SystemClock</span><span class=p>.</span><span class=n>uptimeMillis</span><span class=p>()</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>private</span> <span class=k>val</span> <span class=py>mainHandler</span> <span class=p>=</span> <span class=n>Handler</span><span class=p>(</span><span class=n>Looper</span><span class=p>.</span><span class=n>getMainLooper</span><span class=p>())</span>

  <span class=n>init</span> <span class=p>{</span>
    <span class=c1>// 这里为什么要这么费劲的获取该object的对象呢？</span>
    <span class=c1>// 因为InternalLeakCanary类是上层模块的，这里没有办法直接引用</span>
    <span class=k>val</span> <span class=py>internalLeakCanary</span> <span class=p>=</span> <span class=k>try</span> <span class=p>{</span>
      <span class=k>val</span> <span class=py>leakCanaryListener</span> <span class=p>=</span> <span class=n>Class</span><span class=p>.</span><span class=n>forName</span><span class=p>(</span><span class=s>&quot;leakcanary.internal.InternalLeakCanary&quot;</span><span class=p>)</span>
      <span class=n>leakCanaryListener</span><span class=p>.</span><span class=n>getDeclaredField</span><span class=p>(</span><span class=s>&quot;INSTANCE&quot;</span><span class=p>)</span>
          <span class=p>.</span><span class=k>get</span><span class=p>(</span><span class=k>null</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>ignored</span><span class=p>:</span> <span class=n>Throwable</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>NoLeakCanary</span>
    <span class=p>}</span>
    <span class=n>@kotlin</span><span class=p>.</span><span class=n>Suppress</span><span class=p>(</span><span class=s>&quot;UNCHECKED_CAST&quot;</span><span class=p>)</span>
    <span class=n>onAppWatcherInstalled</span> <span class=p>=</span> <span class=n>internalLeakCanary</span> <span class=k>as</span> <span class=p>(</span><span class=n>Application</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>Unit</span>
  <span class=p>}</span>

  <span class=c1>// 主线程抛出任务，delay 5s</span>
  <span class=k>private</span> <span class=k>val</span> <span class=py>checkRetainedExecutor</span> <span class=p>=</span> <span class=n>Executor</span> <span class=p>{</span>
    <span class=n>mainHandler</span><span class=p>.</span><span class=n>postDelayed</span><span class=p>(</span><span class=n>it</span><span class=p>,</span> <span class=n>AppWatcher</span><span class=p>.</span><span class=n>config</span><span class=p>.</span><span class=n>watchDurationMillis</span><span class=p>)</span>
  <span class=p>}</span>
  <span class=k>val</span> <span class=py>objectWatcher</span> <span class=p>=</span> <span class=n>ObjectWatcher</span><span class=p>(</span>
      <span class=n>clock</span> <span class=p>=</span> <span class=n>clock</span><span class=p>,</span>
      <span class=n>checkRetainedExecutor</span> <span class=p>=</span> <span class=n>checkRetainedExecutor</span><span class=p>,</span>
      <span class=n>isEnabled</span> <span class=p>=</span> <span class=p>{</span> <span class=n>AppWatcher</span><span class=p>.</span><span class=n>config</span><span class=p>.</span><span class=n>enabled</span> <span class=p>}</span>
  <span class=p>)</span>

  <span class=k>fun</span> <span class=nf>install</span><span class=p>(</span><span class=n>application</span><span class=p>:</span> <span class=n>Application</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=n>checkMainThread</span><span class=p>()</span>
    <span class=c1>// lateinit修饰的对象可以通过::&lt;field&gt;.isInitialized来判断有没有初始化</span>
    <span class=c1>// 如果已经初始化了，则不需要再次install</span>
    <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=o>::</span><span class=n>application</span><span class=p>.</span><span class=n>isInitialized</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span>
    <span class=p>}</span>
    <span class=n>InternalAppWatcher</span><span class=p>.</span><span class=n>application</span> <span class=p>=</span> <span class=n>application</span>

    <span class=c1>// 安装ActivityDestroyWatcher、FragmentDestroyWatcher</span>
    <span class=k>val</span> <span class=py>configProvider</span> <span class=p>=</span> <span class=p>{</span> <span class=n>AppWatcher</span><span class=p>.</span><span class=n>config</span> <span class=p>}</span>
    <span class=n>ActivityDestroyWatcher</span><span class=p>.</span><span class=n>install</span><span class=p>(</span><span class=n>application</span><span class=p>,</span> <span class=n>objectWatcher</span><span class=p>,</span> <span class=n>configProvider</span><span class=p>)</span>
    <span class=n>FragmentDestroyWatcher</span><span class=p>.</span><span class=n>install</span><span class=p>(</span><span class=n>application</span><span class=p>,</span> <span class=n>objectWatcher</span><span class=p>,</span> <span class=n>configProvider</span><span class=p>)</span>
    <span class=c1>// 通知上层模块的InternalLeakCanary.invoke方法</span>
    <span class=n>onAppWatcherInstalled</span><span class=p>(</span><span class=n>application</span><span class=p>)</span>
  <span class=p>}</span>
  <span class=p>...</span>
<span class=p>}</span>
</pre></div> <p>在上面的这个install方法中，干了三件事： 1. 初始化一个<code>ObjectWatcher</code>对象：其<code>clock</code>就是<code>SystemClock.uptimeMillis()</code>，<code>checkRetainedExecutor</code>是利用主线程Handler执行的任务 2. Activity、Fragment销毁的观察者的安装 3. 通知InternalLeakCanary，watcher已经安装完成</p> <p>由于Activity、Fragment的销毁不会立刻发生，所以我们先看看第3点中，<code>InternalLeakCanary</code>做了什么工作。<br> <code>InternalLeakCanary</code>的部分声明为<code>object InternalLeakCanary : (Application) -&gt; Unit</code>，所以它到底实现了什么呢。这其实对应kotlin中Functions.kt文件的Function1接口，P1为Application，R为Unit即void：</p> <div class=codehilite><pre><span></span><span class=cm>/** A function that takes 1 argument. */</span>
<span class=k>public</span> <span class=k>interface</span> <span class=nc>Function1</span><span class=p>&lt;</span><span class=k>in</span> <span class=n>P1</span><span class=p>,</span> <span class=k>out</span> <span class=n>R</span><span class=p>&gt;</span> <span class=p>:</span> <span class=n>Function</span><span class=p>&lt;</span><span class=n>R</span><span class=p>&gt;</span> <span class=p>{</span>
    <span class=cm>/** Invokes the function with the specified argument. */</span>
    <span class=k>public</span> <span class=k>operator</span> <span class=k>fun</span> <span class=nf>invoke</span><span class=p>(</span><span class=n>p1</span><span class=p>:</span> <span class=n>P1</span><span class=p>):</span> <span class=n>R</span>
<span class=p>}</span>
</pre></div> <p>所以接着看<code>InternalLeakCanary.invoke</code>方法即可，该方法也是完成了一些初始化操作，如下：</p> <p><strong>InternalLeakCanary.kt</strong> </p> <div class=codehilite><pre><span></span><span class=k>override</span> <span class=k>fun</span> <span class=nf>invoke</span><span class=p>(</span><span class=n>application</span><span class=p>:</span> <span class=n>Application</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>this</span><span class=p>.</span><span class=n>application</span> <span class=p>=</span> <span class=n>application</span>

  <span class=c1>// 内存泄漏时回调该类的方法</span>
  <span class=n>AppWatcher</span><span class=p>.</span><span class=n>objectWatcher</span><span class=p>.</span><span class=n>addOnObjectRetainedListener</span><span class=p>(</span><span class=k>this</span><span class=p>)</span>

  <span class=k>val</span> <span class=py>heapDumper</span> <span class=p>=</span> <span class=n>AndroidHeapDumper</span><span class=p>(</span><span class=n>application</span><span class=p>,</span> <span class=n>leakDirectoryProvider</span><span class=p>)</span>

  <span class=c1>// gcTrigger使用的默认的</span>
  <span class=k>val</span> <span class=py>gcTrigger</span> <span class=p>=</span> <span class=n>GcTrigger</span><span class=p>.</span><span class=n>Default</span>

  <span class=k>val</span> <span class=py>configProvider</span> <span class=p>=</span> <span class=p>{</span> <span class=n>LeakCanary</span><span class=p>.</span><span class=n>config</span> <span class=p>}</span>

  <span class=c1>// HandlerThread + Handler 来处理后台任务</span>
  <span class=k>val</span> <span class=py>handlerThread</span> <span class=p>=</span> <span class=n>HandlerThread</span><span class=p>(</span><span class=n>LEAK_CANARY_THREAD_NAME</span><span class=p>)</span>
  <span class=n>handlerThread</span><span class=p>.</span><span class=n>start</span><span class=p>()</span>
  <span class=k>val</span> <span class=py>backgroundHandler</span> <span class=p>=</span> <span class=n>Handler</span><span class=p>(</span><span class=n>handlerThread</span><span class=p>.</span><span class=n>looper</span><span class=p>)</span>

  <span class=n>heapDumpTrigger</span> <span class=p>=</span> <span class=n>HeapDumpTrigger</span><span class=p>(</span>
      <span class=n>application</span><span class=p>,</span> <span class=n>backgroundHandler</span><span class=p>,</span> <span class=n>AppWatcher</span><span class=p>.</span><span class=n>objectWatcher</span><span class=p>,</span> <span class=n>gcTrigger</span><span class=p>,</span> <span class=n>heapDumper</span><span class=p>,</span>
      <span class=n>configProvider</span>
  <span class=p>)</span>
  <span class=c1>// 自定义的扩展方法来检测App是否可见（处于前台）</span>
  <span class=n>application</span><span class=p>.</span><span class=n>registerVisibilityListener</span> <span class=p>{</span> <span class=n>applicationVisible</span> <span class=p>-&gt;</span>
    <span class=k>this</span><span class=p>.</span><span class=n>applicationVisible</span> <span class=p>=</span> <span class=n>applicationVisible</span>
    <span class=n>heapDumpTrigger</span><span class=p>.</span><span class=n>onApplicationVisibilityChanged</span><span class=p>(</span><span class=n>applicationVisible</span><span class=p>)</span>
  <span class=p>}</span>
  <span class=c1>// 动态添加Shortcut</span>
  <span class=n>addDynamicShortcut</span><span class=p>(</span><span class=n>application</span><span class=p>)</span>

  <span class=n>disableDumpHeapInInstrumentationTests</span><span class=p>()</span>
<span class=p>}</span>
</pre></div> <p>其实上面这些初始化的变量，大部分我们都不会在检测内存泄漏时遇到，这些变量大部分都与dump heap有关。<br> 这里展开说说其中的“自定义的扩展方法来检测App是否可见（处于前台）”这里面的实现原理，这个需求在日常开发中也会用到，也是通过向Application注册Activity生命周期回调，通过计算start-stop的Activity个数来实现的：</p> <p><strong>leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt</strong></p> <div class=codehilite><pre><span></span><span class=k>internal</span> <span class=k>class</span> <span class=nc>VisibilityTracker</span><span class=p>(</span>
  <span class=k>private</span> <span class=k>val</span> <span class=py>listener</span><span class=p>:</span> <span class=p>(</span><span class=n>Boolean</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>Unit</span>
<span class=p>)</span> <span class=p>:</span>
    <span class=n>Application</span><span class=p>.</span><span class=n>ActivityLifecycleCallbacks</span> <span class=k>by</span> <span class=n>noOpDelegate</span><span class=p>()</span> <span class=p>{</span>

  <span class=k>private</span> <span class=k>var</span> <span class=py>startedActivityCount</span> <span class=p>=</span> <span class=m>0</span>

  <span class=cm>/**</span>
<span class=cm>   * Visible activities are any activity started but not stopped yet. An activity can be paused</span>
<span class=cm>   * yet visible: this will happen when another activity shows on top with a transparent background</span>
<span class=cm>   * and the activity behind won&#39;t get touch inputs but still need to render / animate.</span>
<span class=cm>   */</span>
  <span class=k>private</span> <span class=k>var</span> <span class=py>hasVisibleActivities</span><span class=p>:</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=k>false</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>onActivityStarted</span><span class=p>(</span><span class=n>activity</span><span class=p>:</span> <span class=n>Activity</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>startedActivityCount</span><span class=p>++</span>
    <span class=k>if</span> <span class=p>(!</span><span class=n>hasVisibleActivities</span> <span class=p>&amp;&amp;</span> <span class=n>startedActivityCount</span> <span class=p>==</span> <span class=m>1</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>hasVisibleActivities</span> <span class=p>=</span> <span class=k>true</span>
      <span class=n>listener</span><span class=p>.</span><span class=n>invoke</span><span class=p>(</span><span class=k>true</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>onActivityStopped</span><span class=p>(</span><span class=n>activity</span><span class=p>:</span> <span class=n>Activity</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// This could happen if the callbacks were registered after some activities were already</span>
    <span class=c1>// started. In that case we effectively considers those past activities as not visible.</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>startedActivityCount</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>startedActivityCount</span><span class=p>--</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>hasVisibleActivities</span> <span class=p>&amp;&amp;</span> <span class=n>startedActivityCount</span> <span class=p>==</span> <span class=m>0</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>activity</span><span class=p>.</span><span class=n>isChangingConfigurations</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>hasVisibleActivities</span> <span class=p>=</span> <span class=k>false</span>
      <span class=n>listener</span><span class=p>.</span><span class=n>invoke</span><span class=p>(</span><span class=k>false</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=k>internal</span> <span class=k>fun</span> <span class=nc>Application</span><span class=p>.</span><span class=nf>registerVisibilityListener</span><span class=p>(</span><span class=n>listener</span><span class=p>:</span> <span class=p>(</span><span class=n>Boolean</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>Unit</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>registerActivityLifecycleCallbacks</span><span class=p>(</span><span class=n>VisibilityTracker</span><span class=p>(</span><span class=n>listener</span><span class=p>))</span>
<span class=p>}</span>
</pre></div> <p>上面就是LeakCanary的初始化代码了，下一节开始说说Activity与Fragment是如何检测内存泄漏的。</p> <h3 id=32-activityfragment>3.2 如何观察Activity、Fragment<a class=headerlink href=#32-activityfragment title="Permanent link">&para;</a></h3> <p>在上一节LeakCanary2初始化中，我们还没有讲解下面两行代码：</p> <div class=codehilite><pre><span></span><span class=n>ActivityDestroyWatcher</span><span class=p>.</span><span class=n>install</span><span class=p>(</span><span class=n>application</span><span class=p>,</span> <span class=n>objectWatcher</span><span class=p>,</span> <span class=n>configProvider</span><span class=p>)</span>
<span class=n>FragmentDestroyWatcher</span><span class=p>.</span><span class=n>install</span><span class=p>(</span><span class=n>application</span><span class=p>,</span> <span class=n>objectWatcher</span><span class=p>,</span> <span class=n>configProvider</span><span class=p>)</span>
</pre></div> <p>这两行代码都是通过向Application注册<code>registerActivityLifecycleCallbacks</code>从而获取每个启动的Activity，然后</p> <ul> <li>对于Activity而言，直接观察Activity即可</li> <li>对于Fragment而言，由于Fragment需要依附于Activity，且需要从Activity中获取FragmentManager，然后通过其<code>registerFragmentLifecycleCallbacks</code>方法观察Fragment</li> </ul> <p>上面两行代码就是这个实现逻辑。 先看看Activity的观察逻辑：</p> <p><strong>leakcanary-object-watcher-android/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt</strong></p> <div class=codehilite><pre><span></span><span class=k>internal</span> <span class=k>class</span> <span class=nc>ActivityDestroyWatcher</span> <span class=k>private</span> <span class=k>constructor</span><span class=p>(</span>
  <span class=k>private</span> <span class=k>val</span> <span class=py>objectWatcher</span><span class=p>:</span> <span class=n>ObjectWatcher</span><span class=p>,</span>
  <span class=k>private</span> <span class=k>val</span> <span class=py>configProvider</span><span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=n>Config</span>
<span class=p>)</span> <span class=p>{</span>

  <span class=k>private</span> <span class=k>val</span> <span class=py>lifecycleCallbacks</span> <span class=p>=</span>
    <span class=k>object</span> <span class=p>:</span> <span class=nc>Application</span><span class=p>.</span><span class=n>ActivityLifecycleCallbacks</span> <span class=k>by</span> <span class=n>noOpDelegate</span><span class=p>()</span> <span class=p>{</span>
      <span class=c1>// noOpDelegate()是一个动态代理的实现，不过里面没有写任何逻辑 所以是no op</span>
      <span class=c1>// 此处相当于一个适配器方法</span>
      <span class=k>override</span> <span class=k>fun</span> <span class=nf>onActivityDestroyed</span><span class=p>(</span><span class=n>activity</span><span class=p>:</span> <span class=n>Activity</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>configProvider</span><span class=p>().</span><span class=n>watchActivities</span><span class=p>)</span> <span class=p>{</span>
          <span class=n>objectWatcher</span><span class=p>.</span><span class=n>watch</span><span class=p>(</span><span class=n>activity</span><span class=p>)</span>
        <span class=p>}</span>
      <span class=p>}</span>
    <span class=p>}</span>

  <span class=k>companion</span> <span class=k>object</span> <span class=p>{</span>
    <span class=k>fun</span> <span class=nf>install</span><span class=p>(</span>
      <span class=n>application</span><span class=p>:</span> <span class=n>Application</span><span class=p>,</span>
      <span class=n>objectWatcher</span><span class=p>:</span> <span class=n>ObjectWatcher</span><span class=p>,</span>
      <span class=n>configProvider</span><span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=n>Config</span>
    <span class=p>)</span> <span class=p>{</span>
      <span class=k>val</span> <span class=py>activityDestroyWatcher</span> <span class=p>=</span>
        <span class=n>ActivityDestroyWatcher</span><span class=p>(</span><span class=n>objectWatcher</span><span class=p>,</span> <span class=n>configProvider</span><span class=p>)</span>
      <span class=n>application</span><span class=p>.</span><span class=n>registerActivityLifecycleCallbacks</span><span class=p>(</span><span class=n>activityDestroyWatcher</span><span class=p>.</span><span class=n>lifecycleCallbacks</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>上面的逻辑很简单，就是对于每个Activity，在其<code>onDestroy</code>方法调用之后，调用<code>objectWatcher.watch</code>观察这个Activity。该方法的逻辑我们下一节再说。</p> <p>然后我们看看Fragment里面的观察逻辑，由于Fragment有两种： 1. <code>android.app.Fragment</code> 2. support包里面的<code>androidx.fragment.app.Fragment</code></p> <p>前者的FragmentLifecycleCallbacks有API Level限制，限制为O；后者则没有API限制了，但是有androidx限制。所以FragmentDestroyWatcher会判断这两个的是否满足条件，满足条件后才会进行观察。</p> <p><strong>leakcanary-object-watcher-android/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt</strong></p> <div class=codehilite><pre><span></span><span class=cm>/**</span>
<span class=cm> * Internal class used to watch for fragments leaks.</span>
<span class=cm> */</span>
<span class=k>internal</span> <span class=k>object</span> <span class=nc>FragmentDestroyWatcher</span> <span class=p>{</span>

  <span class=k>private</span> <span class=k>const</span> <span class=k>val</span> <span class=py>ANDROIDX_FRAGMENT_CLASS_NAME</span> <span class=p>=</span> <span class=s>&quot;androidx.fragment.app.Fragment&quot;</span>
  <span class=k>private</span> <span class=k>const</span> <span class=k>val</span> <span class=py>ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME</span> <span class=p>=</span>
    <span class=s>&quot;leakcanary.internal.AndroidXFragmentDestroyWatcher&quot;</span>

  <span class=k>fun</span> <span class=nf>install</span><span class=p>(</span>
    <span class=n>application</span><span class=p>:</span> <span class=n>Application</span><span class=p>,</span>
    <span class=n>objectWatcher</span><span class=p>:</span> <span class=n>ObjectWatcher</span><span class=p>,</span>
    <span class=n>configProvider</span><span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=n>AppWatcher</span><span class=p>.</span><span class=n>Config</span>
  <span class=p>)</span> <span class=p>{</span>
    <span class=k>val</span> <span class=py>fragmentDestroyWatchers</span> <span class=p>=</span> <span class=n>mutableListOf</span><span class=p>&lt;(</span><span class=n>Activity</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>Unit</span><span class=p>&gt;()</span>

    <span class=c1>// 如果SDK大于等于O，则添加android.app.Fragment的观察者</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>SDK_INT</span> <span class=p>&gt;=</span> <span class=n>O</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>fragmentDestroyWatchers</span><span class=p>.</span><span class=n>add</span><span class=p>(</span>
          <span class=n>AndroidOFragmentDestroyWatcher</span><span class=p>(</span><span class=n>objectWatcher</span><span class=p>,</span> <span class=n>configProvider</span><span class=p>)</span>
      <span class=p>)</span>
    <span class=p>}</span>

    <span class=c1>// 通过反射判定androidx.fragment.app.Fragment以及其观察者是否存在</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>classAvailable</span><span class=p>(</span><span class=n>ANDROIDX_FRAGMENT_CLASS_NAME</span><span class=p>)</span> <span class=p>&amp;&amp;</span>
        <span class=n>classAvailable</span><span class=p>(</span><span class=n>ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME</span><span class=p>)</span>
    <span class=p>)</span> <span class=p>{</span>
      <span class=c1>// 反射实例化androidx Fragment的观察者并添加到里面list里面</span>
      <span class=k>val</span> <span class=py>watcherConstructor</span> <span class=p>=</span> <span class=n>Class</span><span class=p>.</span><span class=n>forName</span><span class=p>(</span><span class=n>ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME</span><span class=p>)</span>
          <span class=p>.</span><span class=n>getDeclaredConstructor</span><span class=p>(</span><span class=n>ObjectWatcher</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>,</span> <span class=n>Function0</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
      <span class=n>@kotlin</span><span class=p>.</span><span class=n>Suppress</span><span class=p>(</span><span class=s>&quot;UNCHECKED_CAST&quot;</span><span class=p>)</span>
      <span class=n>fragmentDestroyWatchers</span><span class=p>.</span><span class=n>add</span><span class=p>(</span>
          <span class=n>watcherConstructor</span><span class=p>.</span><span class=n>newInstance</span><span class=p>(</span><span class=n>objectWatcher</span><span class=p>,</span> <span class=n>configProvider</span><span class=p>)</span> <span class=k>as</span> <span class=p>(</span><span class=n>Activity</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>Unit</span>
      <span class=p>)</span>
    <span class=p>}</span>

    <span class=c1>// 如果watcher为空，则不需要进行观察了</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>fragmentDestroyWatchers</span><span class=p>.</span><span class=n>size</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span>
    <span class=p>}</span>

    <span class=c1>// 对每个Activity里面的所有的Fragment进行观察</span>
    <span class=n>application</span><span class=p>.</span><span class=n>registerActivityLifecycleCallbacks</span><span class=p>(</span><span class=k>object</span> <span class=p>:</span> <span class=nc>Application</span><span class=p>.</span><span class=n>ActivityLifecycleCallbacks</span> <span class=k>by</span> <span class=n>noOpDelegate</span><span class=p>()</span> <span class=p>{</span>
      <span class=k>override</span> <span class=k>fun</span> <span class=nf>onActivityCreated</span><span class=p>(</span>
        <span class=n>activity</span><span class=p>:</span> <span class=n>Activity</span><span class=p>,</span>
        <span class=n>savedInstanceState</span><span class=p>:</span> <span class=n>Bundle</span><span class=p>?</span>
      <span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=n>watcher</span> <span class=k>in</span> <span class=n>fragmentDestroyWatchers</span><span class=p>)</span> <span class=p>{</span>
          <span class=n>watcher</span><span class=p>(</span><span class=n>activity</span><span class=p>)</span>
        <span class=p>}</span>
      <span class=p>}</span>
    <span class=p>})</span>
  <span class=p>}</span>

  <span class=k>private</span> <span class=k>fun</span> <span class=nf>classAvailable</span><span class=p>(</span><span class=n>className</span><span class=p>:</span> <span class=n>String</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>try</span> <span class=p>{</span>
      <span class=n>Class</span><span class=p>.</span><span class=n>forName</span><span class=p>(</span><span class=n>className</span><span class=p>)</span>
      <span class=k>true</span>
    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>e</span><span class=p>:</span> <span class=n>ClassNotFoundException</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>false</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p><code>AndroidOFragmentDestroyWatcher</code>、<code>AndroidXFragmentDestroyWatcher</code>两者的源码非常类似，只是针对的Fragment不同而调用的API不同而已，下面以<code>AndroidXFragmentDestroyWatcher</code>为例看看里面是如何实现的。</p> <p><strong>leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt</strong></p> <div class=codehilite><pre><span></span><span class=k>internal</span> <span class=k>class</span> <span class=nc>AndroidXFragmentDestroyWatcher</span><span class=p>(</span>
  <span class=k>private</span> <span class=k>val</span> <span class=py>objectWatcher</span><span class=p>:</span> <span class=n>ObjectWatcher</span><span class=p>,</span>
  <span class=k>private</span> <span class=k>val</span> <span class=py>configProvider</span><span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=n>Config</span>
<span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=n>Activity</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>Unit</span> <span class=p>{</span>

  <span class=k>private</span> <span class=k>val</span> <span class=py>fragmentLifecycleCallbacks</span> <span class=p>=</span> <span class=k>object</span> <span class=p>:</span> <span class=nc>FragmentManager</span><span class=p>.</span><span class=n>FragmentLifecycleCallbacks</span><span class=p>()</span> <span class=p>{</span>

    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onFragmentViewDestroyed</span><span class=p>(</span>
      <span class=n>fm</span><span class=p>:</span> <span class=n>FragmentManager</span><span class=p>,</span>
      <span class=n>fragment</span><span class=p>:</span> <span class=n>Fragment</span>
    <span class=p>)</span> <span class=p>{</span>
      <span class=k>val</span> <span class=py>view</span> <span class=p>=</span> <span class=n>fragment</span><span class=p>.</span><span class=n>view</span>
      <span class=k>if</span> <span class=p>(</span><span class=n>view</span> <span class=p>!=</span> <span class=k>null</span> <span class=p>&amp;&amp;</span> <span class=n>configProvider</span><span class=p>().</span><span class=n>watchFragmentViews</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>objectWatcher</span><span class=p>.</span><span class=n>watch</span><span class=p>(</span><span class=n>view</span><span class=p>)</span>
      <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onFragmentDestroyed</span><span class=p>(</span>
      <span class=n>fm</span><span class=p>:</span> <span class=n>FragmentManager</span><span class=p>,</span>
      <span class=n>fragment</span><span class=p>:</span> <span class=n>Fragment</span>
    <span class=p>)</span> <span class=p>{</span>
      <span class=k>if</span> <span class=p>(</span><span class=n>configProvider</span><span class=p>().</span><span class=n>watchFragments</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>objectWatcher</span><span class=p>.</span><span class=n>watch</span><span class=p>(</span><span class=n>fragment</span><span class=p>)</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>override</span> <span class=k>fun</span> <span class=nf>invoke</span><span class=p>(</span><span class=n>activity</span><span class=p>:</span> <span class=n>Activity</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>activity</span> <span class=k>is</span> <span class=n>FragmentActivity</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>val</span> <span class=py>supportFragmentManager</span> <span class=p>=</span> <span class=n>activity</span><span class=p>.</span><span class=n>supportFragmentManager</span>
      <span class=n>supportFragmentManager</span><span class=p>.</span><span class=n>registerFragmentLifecycleCallbacks</span><span class=p>(</span><span class=n>fragmentLifecycleCallbacks</span><span class=p>,</span> <span class=k>true</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>实现就是向Activity的FragmentManager注册<code>FragmentLifecycleCallbacks</code>，这样在Fragment调用<code>onDestroyView</code>和<code>onDestory</code>之后就能观察Fragment的View或者Fragment本身了。</p> <h3 id=33>3.3 内存泄漏判定<a class=headerlink href=#33 title="Permanent link">&para;</a></h3> <p>现在我们来看看<code>ObjectWatcher.watch(Any)</code>方法，在上面一节中我们看到，Activity、Fragment的View、Fragment都是由该方法进行观察的，所以最后还是统一回到了这里。</p> <p><strong>leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt</strong></p> <div class=codehilite><pre><span></span><span class=cm>/**</span>
<span class=cm>  * Identical to [watch] with an empty string reference name.</span>
<span class=cm>  */</span>
<span class=n>@Synchronized</span> <span class=k>fun</span> <span class=nf>watch</span><span class=p>(</span><span class=n>watchedObject</span><span class=p>:</span> <span class=n>Any</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>watch</span><span class=p>(</span><span class=n>watchedObject</span><span class=p>,</span> <span class=s>&quot;&quot;</span><span class=p>)</span>
<span class=p>}</span>

<span class=cm>/**</span>
<span class=cm>  * Watches the provided [watchedObject].</span>
<span class=cm>  *</span>
<span class=cm>  * @param name A logical identifier for the watched object.</span>
<span class=cm>  */</span>
<span class=n>@Synchronized</span> <span class=k>fun</span> <span class=nf>watch</span><span class=p>(</span>
  <span class=n>watchedObject</span><span class=p>:</span> <span class=n>Any</span><span class=p>,</span>
  <span class=n>name</span><span class=p>:</span> <span class=n>String</span>
<span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(!</span><span class=n>isEnabled</span><span class=p>())</span> <span class=p>{</span>
    <span class=k>return</span>
  <span class=p>}</span>
  <span class=c1>// 将ReferenceQueue中出现的弱引用移除</span>
  <span class=c1>// 这是一个出现频率很高的方法，也是内存泄漏检测的关键点之一</span>
  <span class=n>removeWeaklyReachableObjects</span><span class=p>()</span>
  <span class=k>val</span> <span class=py>key</span> <span class=p>=</span> <span class=n>UUID</span><span class=p>.</span><span class=n>randomUUID</span><span class=p>()</span>
      <span class=p>.</span><span class=n>toString</span><span class=p>()</span>
  <span class=c1>// 记下观测开始的时间</span>
  <span class=k>val</span> <span class=py>watchUptimeMillis</span> <span class=p>=</span> <span class=n>clock</span><span class=p>.</span><span class=n>uptimeMillis</span><span class=p>()</span>
  <span class=c1>// 这里创建了一个自定义的弱引用，且调用了基类的WeakReference&lt;Any&gt;(referent, referenceQueue)构造器</span>
  <span class=c1>// 这样的话，弱引用被回收之前会出现在ReferenceQueue中</span>
  <span class=k>val</span> <span class=py>reference</span> <span class=p>=</span>
    <span class=n>KeyedWeakReference</span><span class=p>(</span><span class=n>watchedObject</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>watchUptimeMillis</span><span class=p>,</span> <span class=n>queue</span><span class=p>)</span>
  <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span>
      <span class=s>&quot;Watching &quot;</span> <span class=p>+</span>
          <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>watchedObject</span> <span class=k>is</span> <span class=n>Class</span><span class=p>&lt;*&gt;)</span> <span class=n>watchedObject</span><span class=p>.</span><span class=n>toString</span><span class=p>()</span> <span class=k>else</span> <span class=s>&quot;instance of ${watchedObject.javaClass.name}&quot;</span><span class=p>)</span> <span class=p>+</span>
          <span class=p>(</span><span class=k>if</span> <span class=p>(</span><span class=n>name</span><span class=p>.</span><span class=n>isNotEmpty</span><span class=p>())</span> <span class=s>&quot; named $name&quot;</span> <span class=k>else</span> <span class=s>&quot;&quot;</span><span class=p>)</span> <span class=p>+</span>
          <span class=s>&quot; with key $key&quot;</span>
  <span class=p>}</span>

  <span class=c1>// 将key-reference保存到map中</span>
  <span class=n>watchedObjects</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=p>=</span> <span class=n>reference</span>
  <span class=c1>// 主线程5秒之后执行moveToRetained(key)方法</span>
  <span class=n>checkRetainedExecutor</span><span class=p>.</span><span class=n>execute</span> <span class=p>{</span>
    <span class=n>moveToRetained</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>上面这段代码便是LeakCanary的关键代码之一： 1. 将要观测的对象使用WeakReference保存起来，并在构造时传入一个ReferenceQueue，这样待观测的对象在被回收之前，会出现在ReferenceQueue中。 2. 5秒钟之后再检查一下是否出现在了引用队列中，若出现了，则没有泄露。</p> <p>为什么会是5S，这里猜测与Android GC有关。在Activity.H中，收到<code>GC_WHEN_IDLE</code>消息时会进行<code>Looper.myQueue().addIdleHandler(mGcIdler)</code>，而<code>mGcIdler</code>最后会触发<code>doGcIfNeeded</code>操作，在该方法中会判断上次GC与现在时间的差值，而这个值就是<code>MIN_TIME_BETWEEN_GCS = 5*1000</code>。</p> <p>回到上面的代码，需要了解两个方法<code>removeWeaklyReachableObjects()</code>与<code>moveToRetained(key)</code>。前者比较简单，就会将引用队列中出现的对象从map中移除，因为它们没有发生内存泄漏。但是注意一下注释，这里强调了一点：<strong>弱引用入队列发生在终结函数或者GC发生之前</strong>。</p> <div class=codehilite><pre><span></span><span class=k>private</span> <span class=k>fun</span> <span class=nf>removeWeaklyReachableObjects</span><span class=p>()</span> <span class=p>{</span>
  <span class=c1>// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span>
  <span class=c1>// reachable. This is before finalization or garbage collection has actually happened.</span>
  <span class=k>var</span> <span class=py>ref</span><span class=p>:</span> <span class=n>KeyedWeakReference</span><span class=p>?</span>
  <span class=k>do</span> <span class=p>{</span>
    <span class=n>ref</span> <span class=p>=</span> <span class=n>queue</span><span class=p>.</span><span class=n>poll</span><span class=p>()</span> <span class=k>as</span> <span class=n>KeyedWeakReference</span><span class=p>?</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ref</span> <span class=p>!=</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>watchedObjects</span><span class=p>.</span><span class=n>remove</span><span class=p>(</span><span class=n>ref</span><span class=p>.</span><span class=n>key</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>ref</span> <span class=p>!=</span> <span class=k>null</span><span class=p>)</span>
<span class=p>}</span>
</pre></div> <p>然后我们接着看重头戏<code>moveToRetained</code>方法：</p> <div class=codehilite><pre><span></span><span class=n>@Synchronized</span> <span class=k>private</span> <span class=k>fun</span> <span class=nf>moveToRetained</span><span class=p>(</span><span class=n>key</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>removeWeaklyReachableObjects</span><span class=p>()</span>
  <span class=k>val</span> <span class=py>retainedRef</span> <span class=p>=</span> <span class=n>watchedObjects</span><span class=p>[</span><span class=n>key</span><span class=p>]</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>retainedRef</span> <span class=p>!=</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>retainedRef</span><span class=p>.</span><span class=n>retainedUptimeMillis</span> <span class=p>=</span> <span class=n>clock</span><span class=p>.</span><span class=n>uptimeMillis</span><span class=p>()</span>
    <span class=n>onObjectRetainedListeners</span><span class=p>.</span><span class=n>forEach</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>onObjectRetained</span><span class=p>()</span> <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>5秒钟到了，还是先将引用队列中出现的对象从map中移除，因为它们没有内存泄漏。然后判断key还在不在map中，如果在的话，说明可能发生了内存泄漏。此时记下内存泄漏发生的时间，即更新<code>retainedUptimeMillis</code>字段，然后通知所有的对象，内存泄漏发生了。 </p> <p>我们回忆一下，此处的<code>onObjectRetainedListeners</code>只有一个，就是我们在Activity、Fragment的观测者安装完毕后，通知了<code>InternalLeakCanary</code>，而<code>InternalLeakCanary</code>添加了一个监听器，就是它自己。所以我们看看<code>InternalLeakCanary.onObjectRetained()</code>方法：</p> <p><strong>leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt</strong></p> <div class=codehilite><pre><span></span><span class=k>override</span> <span class=k>fun</span> <span class=nf>onObjectRetained</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=o>::</span><span class=n>heapDumpTrigger</span><span class=p>.</span><span class=n>isInitialized</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>heapDumpTrigger</span><span class=p>.</span><span class=n>onObjectRetained</span><span class=p>()</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>跟踪一下<code>HeapDumpTrigger.onObjectRetained()</code>方法：</p> <p><strong>leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt</strong></p> <div class=codehilite><pre><span></span><span class=k>fun</span> <span class=nf>onObjectRetained</span><span class=p>()</span> <span class=p>{</span>
  <span class=n>scheduleRetainedObjectCheck</span><span class=p>(</span><span class=s>&quot;found new object retained&quot;</span><span class=p>)</span>
<span class=p>}</span>

<span class=k>private</span> <span class=k>fun</span> <span class=nf>scheduleRetainedObjectCheck</span><span class=p>(</span><span class=n>reason</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>checkScheduled</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span> <span class=s>&quot;Already scheduled retained check, ignoring ($reason)&quot;</span> <span class=p>}</span>
    <span class=k>return</span>
  <span class=p>}</span>
  <span class=n>checkScheduled</span> <span class=p>=</span> <span class=k>true</span>
  <span class=n>backgroundHandler</span><span class=p>.</span><span class=n>post</span> <span class=p>{</span>
    <span class=n>checkScheduled</span> <span class=p>=</span> <span class=k>false</span>
    <span class=n>checkRetainedObjects</span><span class=p>(</span><span class=n>reason</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=k>private</span> <span class=k>fun</span> <span class=nf>checkRetainedObjects</span><span class=p>(</span><span class=n>reason</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>val</span> <span class=py>config</span> <span class=p>=</span> <span class=n>configProvider</span><span class=p>()</span>
  <span class=c1>// A tick will be rescheduled when this is turned back on.</span>
  <span class=k>if</span> <span class=p>(!</span><span class=n>config</span><span class=p>.</span><span class=n>dumpHeap</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span> <span class=s>&quot;No checking for retained object: LeakCanary.Config.dumpHeap is false&quot;</span> <span class=p>}</span>
    <span class=k>return</span>
  <span class=p>}</span>
  <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span> <span class=s>&quot;Checking retained object because $reason&quot;</span> <span class=p>}</span>

  <span class=k>var</span> <span class=py>retainedReferenceCount</span> <span class=p>=</span> <span class=n>objectWatcher</span><span class=p>.</span><span class=n>retainedObjectCount</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>retainedReferenceCount</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>gcTrigger</span><span class=p>.</span><span class=n>runGc</span><span class=p>()</span>
    <span class=n>retainedReferenceCount</span> <span class=p>=</span> <span class=n>objectWatcher</span><span class=p>.</span><span class=n>retainedObjectCount</span>
  <span class=p>}</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>checkRetainedCount</span><span class=p>(</span><span class=n>retainedReferenceCount</span><span class=p>,</span> <span class=n>config</span><span class=p>.</span><span class=n>retainedVisibleThreshold</span><span class=p>))</span> <span class=k>return</span>

  <span class=k>if</span> <span class=p>(!</span><span class=n>config</span><span class=p>.</span><span class=n>dumpHeapWhenDebugging</span> <span class=p>&amp;&amp;</span> <span class=n>DebuggerControl</span><span class=p>.</span><span class=n>isDebuggerAttached</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>showRetainedCountWithDebuggerAttached</span><span class=p>(</span><span class=n>retainedReferenceCount</span><span class=p>)</span>
    <span class=n>scheduleRetainedObjectCheck</span><span class=p>(</span><span class=s>&quot;debugger was attached&quot;</span><span class=p>,</span> <span class=n>WAIT_FOR_DEBUG_MILLIS</span><span class=p>)</span>
    <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span>
        <span class=s>&quot;Not checking for leaks while the debugger is attached, will retry in $WAIT_FOR_DEBUG_MILLIS ms&quot;</span>
    <span class=p>}</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span> <span class=s>&quot;Found $retainedReferenceCount retained references, dumping the heap&quot;</span> <span class=p>}</span>
  <span class=k>val</span> <span class=py>heapDumpUptimeMillis</span> <span class=p>=</span> <span class=n>SystemClock</span><span class=p>.</span><span class=n>uptimeMillis</span><span class=p>()</span>
  <span class=n>KeyedWeakReference</span><span class=p>.</span><span class=n>heapDumpUptimeMillis</span> <span class=p>=</span> <span class=n>heapDumpUptimeMillis</span>
  <span class=n>dismissRetainedCountNotification</span><span class=p>()</span>
  <span class=k>val</span> <span class=py>heapDumpFile</span> <span class=p>=</span> <span class=n>heapDumper</span><span class=p>.</span><span class=n>dumpHeap</span><span class=p>()</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>heapDumpFile</span> <span class=p>==</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span> <span class=s>&quot;Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms&quot;</span> <span class=p>}</span>
    <span class=n>scheduleRetainedObjectCheck</span><span class=p>(</span><span class=s>&quot;failed to dump heap&quot;</span><span class=p>,</span> <span class=n>WAIT_AFTER_DUMP_FAILED_MILLIS</span><span class=p>)</span>
    <span class=n>showRetainedCountWithHeapDumpFailed</span><span class=p>(</span><span class=n>retainedReferenceCount</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>
  <span class=n>lastDisplayedRetainedObjectCount</span> <span class=p>=</span> <span class=m>0</span>
  <span class=n>objectWatcher</span><span class=p>.</span><span class=n>clearObjectsWatchedBefore</span><span class=p>(</span><span class=n>heapDumpUptimeMillis</span><span class=p>)</span>

  <span class=n>HeapAnalyzerService</span><span class=p>.</span><span class=n>runAnalysis</span><span class=p>(</span><span class=n>application</span><span class=p>,</span> <span class=n>heapDumpFile</span><span class=p>)</span>
<span class=p>}</span>
</pre></div> <p>上面的代码就是对于内存泄漏判定的代码了，首先进入<code>onObjectRetained</code>方法，该方法会调用<code>scheduleRetainedObjectCheck</code>方法。此方法也就是在后台线程中执行<code>checkRetainedObjects</code>方法来检查泄漏的对象： 1. 首先获取泄漏对象的个数，如果大于0，则GC一次之后再次获取 2. 如果此时泄漏对象的个数大于等于5个<code>config.retainedVisibleThreshold</code>，则继续执行下面的代码，准备dump heap 3. 如果config里面配置的“调试时不允许dump heap”为false（默认值）且正在调试，则20s之后再试 4. 否则可以开始dump heap：此时会先记下dump发生的时间，取消内存泄漏通知，dump heap，清除所有观测事件小于等于dump发生时间的对象（因为这些对象已经处理完毕了），最后运行HeapAnalyzerService开始分析heap。</p> <p>第26行的代码是如何获取泄露对象的个数的呢？我们想一下，在前面的代码中，主线程5秒之后执行了一段检测的代码，在这里面将所有泄露的对象都记下了当时的时间，存在<code>retainedUptimeMillis</code>字段里面。那么我们遍历所有元素，统计一下该字段不为默认值（-1）的个数即可：</p> <p><strong>leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt</strong></p> <div class=codehilite><pre><span></span><span class=cm>/**</span>
<span class=cm>  * Returns the number of retained objects, ie the number of watched objects that aren&#39;t weakly</span>
<span class=cm>  * reachable, and have been watched for long enough to be considered retained.</span>
<span class=cm>  */</span>
<span class=k>val</span> <span class=py>retainedObjectCount</span><span class=p>:</span> <span class=n>Int</span>
  <span class=n>@Synchronized</span> <span class=k>get</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>removeWeaklyReachableObjects</span><span class=p>()</span>
    <span class=k>return</span> <span class=n>watchedObjects</span><span class=p>.</span><span class=n>count</span> <span class=p>{</span> <span class=n>it</span><span class=p>.</span><span class=n>value</span><span class=p>.</span><span class=n>retainedUptimeMillis</span> <span class=p>!=</span> <span class=p>-</span><span class=m>1L</span> <span class=p>}</span>
  <span class=p>}</span>
</pre></div> <p>第29行，如果有内存泄漏的话，会调用<code>gcTrigger.runGc()</code>方法，这里的<code>gcTrigger</code>我们提到过，是<code>GcTrigger.Default</code>：</p> <p><strong>leakcanary/leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt</strong></p> <div class=codehilite><pre><span></span><span class=cm>/**</span>
<span class=cm>  * Default implementation of [GcTrigger].</span>
<span class=cm>  */</span>
<span class=k>object</span> <span class=nc>Default</span> <span class=p>:</span> <span class=n>GcTrigger</span> <span class=p>{</span>
  <span class=k>override</span> <span class=k>fun</span> <span class=nf>runGc</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// Code taken from AOSP FinalizationTest:</span>
    <span class=c1>// https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/</span>
    <span class=c1>// java/lang/ref/FinalizationTester.java</span>
    <span class=c1>// System.gc() does not garbage collect every time. Runtime.gc() is</span>
    <span class=c1>// more likely to perform a gc.</span>
    <span class=n>Runtime</span><span class=p>.</span><span class=n>getRuntime</span><span class=p>()</span>
        <span class=p>.</span><span class=n>gc</span><span class=p>()</span>
    <span class=n>enqueueReferences</span><span class=p>()</span>
    <span class=n>System</span><span class=p>.</span><span class=n>runFinalization</span><span class=p>()</span>
  <span class=p>}</span>

  <span class=k>private</span> <span class=k>fun</span> <span class=nf>enqueueReferences</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// Hack. We don&#39;t have a programmatic way to wait for the reference queue daemon to move</span>
    <span class=c1>// references to the appropriate queues.</span>
    <span class=k>try</span> <span class=p>{</span>
      <span class=n>Thread</span><span class=p>.</span><span class=n>sleep</span><span class=p>(</span><span class=m>100</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>e</span><span class=p>:</span> <span class=n>InterruptedException</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>throw</span> <span class=n>AssertionError</span><span class=p>()</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>在上面注释中提到，<code>System.gc()</code>并不会每次都会执行GC，<code>Runtime.gc()</code>更有可能执行GC。<br> 执行一次GC操作之后，下面粗暴的等待100ms，这样有足够的时间可以让弱引用移动到合适的引用队列里面。这就是<code>GcTrigger.Default</code>所干的事情。</p> <p>GCTrigger触发GC之后，再次判断一下发生内存泄漏的对象的个数，如果仍然还有，那么肯定是泄漏无疑了，实锤！！<br> 随后调用<code>checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)</code>方法，判断泄漏对象的个数是否达到了阈值，如果达到了则直接dump heap；否则发出一个内存泄漏的通知。<br> 我们看一下这个方法：</p> <div class=codehilite><pre><span></span><span class=k>private</span> <span class=k>fun</span> <span class=nf>checkRetainedCount</span><span class=p>(</span>
  <span class=n>retainedKeysCount</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span>
  <span class=n>retainedVisibleThreshold</span><span class=p>:</span> <span class=n>Int</span>
<span class=p>):</span> <span class=n>Boolean</span> <span class=p>{</span>
  <span class=c1>// lastDisplayedRetainedObjectCount默认值为0，此处我们肯定有内存泄漏，因此countChanged为true</span>
  <span class=k>val</span> <span class=py>countChanged</span> <span class=p>=</span> <span class=n>lastDisplayedRetainedObjectCount</span> <span class=p>!=</span> <span class=n>retainedKeysCount</span>
  <span class=c1>// 保存下当前的内存泄漏对象的个数</span>
  <span class=n>lastDisplayedRetainedObjectCount</span> <span class=p>=</span> <span class=n>retainedKeysCount</span>
  <span class=c1>// 如果内存泄漏个数为0，则说明已经处理了所有的内存泄漏</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>retainedKeysCount</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span> <span class=s>&quot;No retained objects&quot;</span> <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>countChanged</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>showNoMoreRetainedObjectNotification</span><span class=p>()</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=k>true</span>
  <span class=p>}</span>

  <span class=c1>// 如果泄漏个数小于5个</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>retainedKeysCount</span> <span class=p>&lt;</span> <span class=n>retainedVisibleThreshold</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>applicationVisible</span> <span class=p>||</span> <span class=n>applicationInvisibleLessThanWatchPeriod</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>SharkLog</span><span class=p>.</span><span class=n>d</span> <span class=p>{</span>
          <span class=s>&quot;Found $retainedKeysCount retained objects, which is less than the visible threshold of $retainedVisibleThreshold&quot;</span>
      <span class=p>}</span>
      <span class=c1>// 展示一个内存泄漏发生的通知</span>
      <span class=n>showRetainedCountBelowThresholdNotification</span><span class=p>(</span><span class=n>retainedKeysCount</span><span class=p>,</span> <span class=n>retainedVisibleThreshold</span><span class=p>)</span>
      <span class=c1>// 2秒钟之后再次执行检查泄漏对象的方法，看看泄漏个数是否有变化</span>
      <span class=n>scheduleRetainedObjectCheck</span><span class=p>(</span>
          <span class=s>&quot;Showing retained objects notification&quot;</span><span class=p>,</span> <span class=n>WAIT_FOR_OBJECT_THRESHOLD_MILLIS</span>
      <span class=p>)</span>
      <span class=k>return</span> <span class=k>true</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=c1>// 如果泄漏个数大于等于5个，返回false，则返回后checkRetainedObjects方法会继续执行</span>
  <span class=c1>// 此时就会dump heap</span>
  <span class=k>return</span> <span class=k>false</span>
<span class=p>}</span>
</pre></div> <p>至此，我们已经知道了内存泄漏是如何判定的，正如第3节开头所述：</p> <blockquote> <p><strong>LeakCanary 2.0 beta 3 检测内存泄漏原理</strong>：<br> 在Activity destroy后将Activity的弱引用关联到ReferenceQueue中，这样Activity将要被GC前，会出现在ReferenceQueue中。<br> 随后，会向主线程的抛出一个5秒后执行的Runnable，用于检测内存泄漏。<br> 这段代码首先会将引用队列中出现的对象从观察对象数组中移除，然后再判断要观察的此对象是否存在。若不存在，则说明没有内存泄漏，结束。否则，就说明可能出现了内存泄漏，会调用<code>Runtime.getRuntime().gc()</code>进行GC，等待100ms后再次根据引用队列判断，若仍然出现在引用队列中，那么说明有内存泄漏，此时根据内存泄漏的个数弹出通知或者开始dump hprof。</p> </blockquote> <p>LeakCanary2往后就是如何生成hprof文件以及如何解析了</p> <ul> <li>生成hprof可以使用<code>android.os.Debug.dumpHprofData(String fileName)</code>方法<br> LeakCanary2中对应代码在/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt +88</li> <li>解析hprof文件，LeakCanary2使用的是<a href=https://square.github.io/leakcanary/shark/ >Shark</a>，这个我也不懂</li> </ul> <hr> <div class=md-source-date> <small> 最后更新: 2020年1月14日 </small> </div> <h2 id=__comments>评论</h2> <div id=disqus_thread></div> <script>
    var disqus_config = function () {
      this.page.url = "https://blog.yorek.xyz/about-me/android/3rd-library/leakcanary/";
      this.page.identifier =
        "/android/3rd-library/leakcanary/";
    };
    (function() {
      var d = document, s = d.createElement("script");
      s.src = "//yorekliu.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid"> <a href=../eventbus/ title=EventBus源码解析 class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-flex__cell md-flex__cell--shrink"> <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i> </div> <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"> <span class=md-flex__ellipsis> <span class=md-footer-nav__direction> 上一页 </span> EventBus源码解析 </span> </div> </a> <a href=../permissiondispatcher/ title=PermissionDispatcher源码解析 class="md-flex md-footer-nav__link md-footer-nav__link--next" rel=next> <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"> <span class=md-flex__ellipsis> <span class=md-footer-nav__direction> 下一页 </span> PermissionDispatcher源码解析 </span> </div> <div class="md-flex__cell md-flex__cell--shrink"> <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> &copy; 2020 Yorek </div> powered by <a href=https://www.mkdocs.org>MkDocs</a> and <a href=https://squidfunk.github.io/mkdocs-material/ > Material for MkDocs</a> </div> <div class=md-footer-social> <link rel=stylesheet href=../../../assets/fonts/font-awesome.css> <a href=https://github.com/YorekLiu class="md-footer-social__link fa fa-github"></a> <a href=lyytogether@gmail.com class="md-footer-social__link fa fa-email"></a> </div> </div> </div> </footer> </div> <script src=../../../assets/javascripts/application.808e90bb.js></script> <script src=../../../assets/javascripts/lunr/lunr.stemmer.support.js></script> <script src=../../../assets/javascripts/lunr/tinyseg.js></script> <script src=../../../assets/javascripts/lunr/lunr.ja.js></script> <script>app.initialize({version:"1.0.4",url:{base:"../../.."}})</script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>